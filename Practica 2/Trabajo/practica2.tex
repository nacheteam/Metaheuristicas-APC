\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}

%--------------------------------------------------------%
%         Paquetes usados sólo para esta entrega         %
%--------------------------------------------------------%

\usepackage[hidelinks]{hyperref}
\usepackage{algorithm}
\usepackage{algorithmic}



\author{Ignacio Aguilera Martos \\
	DNI: 77448262V       e-mail: nacheteam@correo.ugr.es \\
	Grupo de prácticas 1 Lunes 17:30-19:30}
\title{Práctica Algoritmos Genéticos y Meméticos APC \\ Metaheurísticas}
\date{Curso 2017-2018}

%Quita la sangría
\setlength{\parindent}{0cm}


\begin{document}
	\maketitle

	\tableofcontents

	\newpage

	%p 56

%	\framebox[16cm][c]{\LaTeX}

	\section{Introducción del problema}
	\label{sec:introProblema}

	Para el problema de clasificación partimos de un conjunto de datos dado por una serie de tuplas que contienen los valores de atributos para cada instancia. Esto es una n-tupla de valores reales en nuestro caso.

	El objetivo del problema es obtener un vector de pesos que asocia un valor en el intervalo $[0,1]$ indicativo de la relevancia de ese atributo. Esta relevancia va referida a lo importante que es en nuestro algoritmo clasificador ese atributo a la hora de computar la distancia entre elementos.

	Resumiendo lo que tenemos es un algoritmo clasificador que utiliza el vector de pesos calculado para predecir la clase a la que pertenece una instancia dada. Este algoritmo clasificador es el KNN con k=1. Lo que hace es calcular según la distancia euclídea (o cualquier otra) la tupla más cercana a la que queremos clasificar ponderando cada atributo con el correspondiente peso del vector, es decir, la distancia entre dos elementos sería:
	$$d(e,f) = \sqrt{\sum_{i=0}^{n}w_i * (e_{i} - f_{i})}$$
	Donde e y f son instancias del conjunto de datos, w el vector de pesos y n la longitud de e y f que es la misma.

	La calificación que se le asigna al vector w depende de dos cosas: la tasa de aciertos y la simplicidad.

	La tasa de aciertos se mide contando el número de aciertos al emplear el clasificador descrito y la simplicidad se mide como el número de elementos del vector de pesos que son menores que 0.2, ya que estos pesos no son empleados por el clasificador, o lo que es lo mismo, son sustituidos por cero. Por lo tanto las calificaciones siguen las fórmulas:
	$$Tasa\_acierto = 100\cdot \frac{nº  \ aciertos}{nº \ datos} \ , \ Tasa\_simplicidad = 100\cdot \frac{nº \ valores \ de \ w \ < \ 0.2}{nº \ de \ atributos}$$
	$$Tasa\_agregada = \frac{1}{2}\cdot Tasa\_acierto + \frac{1}{2}\cdot Tasa\_simplicidad$$
	Cabe destacar que todas las tasas están expresadas en porcentajes, por lo tanto cuanto más cercano sea el valor a 100 mejor es la calificación.

	De esta forma a través del algoritmo que obtiene el vector de pesos para el conjunto de datos dado y el clasificador obtenemos un programa que clasifica de forma automática las nuevas instancias de datos que se introduzcan.


	\section{Introducción de la práctica}
	\label{sec:introPractica}

	En esta práctica he desarrollado algoritmos genéticos tanto estacionarios como generacionales con los dos operadores de cruce propuestos (aritmético y BLX) así como un algoritmo memético basado en el genético generacional.

	Al igual que en la práctica anterior el objetivo es ejecutar estos algoritmos sobre los conjuntos de datos dados para observar su comportamiento y realizar una comparativa entre los mismos. A los algoritmos mencionados anteriormente se les suman el 1NN con todos los pesos a uno, el greedy Relief y la búsqueda local (algoritmos implementados en la primera práctica).

	Igual que en la práctica anterior he realizado un procesamiento de los datos para eliminar tuplas repetidas, de forma que ya tenemos implementado el leave one out para conjuntos distintos en el KNN y además, he implementado una versión más rápida de KNN usando la librería NumPy con la intención de reducir tiempos en la búsqueda local, en los algoritmos genéticos y en los meméticos.

	En la práctica se desarrollará cómo he implementado los algoritmos genéticos (en sus dos variantes) incluyendo los operadores de cruce y mutación así como su adaptación a algoritmo memético.

	\newpage

	\section{Descripción común a todos los algoritmos}

	Los algoritmos empleados han sido el KNN, el algoritmo greedy Relief, la metaheurística de búsqueda local, un algoritmo genético estacionario, un algoritmo genético generacional y un memético basado en el algoritmo genético generacional.

	Estos algoritmos comparten ciertos métodos y operadores que pasaré a explicar en esta sección.

	Para empezar se debe destacar que la representación escogida para las soluciones es un vector de números reales, es decir, si n es el número de características:
	$$w\in \mathbb{R}^n \ t.q. \ \forall i \ con \ 0\leq i < n \ se \ tiene \ w_i \in [0,1]$$
	O lo que es lo mismo, un vector de tamaño n con todas las posiciones rellenas con números del intervalo [0,1].

	A estos números me referiré como pesos asociados a las características, ya que lo que nos indican es el grado de importancia de dicha característica a la hora de clasificar los datos, siendo 1 el máximo de relevancia y 0 el mínimo.

	Así mismo cabe destacar que nuestra intención en este problema es obtener una buena calificación de dicho vector de pesos. Esto lo medimos mediante las tasas de acierto y simplicidad que se definen como:
	$$Tasa\_acierto = 100\cdot \frac{nº  \ aciertos}{nº \ datos} \ , \ Tasa\_simplicidad = 100\cdot \frac{nº \ valores \ de \ w \ < \ 0.2}{nº \ de \ atributos}$$
	$$Tasa\_agregada = \frac{1}{2}\cdot Tasa\_acierto + \frac{1}{2}\cdot Tasa\_simplicidad$$

	La tasa de aciertos lo que nos mide es en un porcentaje cuántas instancias hemos clasificado correctamente mediante el algoritmo KNN usando el vector de pesos w.

	La tasa de simplicidad nos mide cuántos de los valores que tiene el vector de pesos son menores que 0.2. Esto se hace ya que, como imposición del problema, tenemos que si alguno de los pesos es menor que 0.2 no debemos usarlo, o lo que es lo mismo, debemos sustituirlo por un 0 en la función de la distancia que luego describiré. Midiendo esto obtenemos un dato de cuanto sobreajuste ha tenido nuestro algoritmo a la hora de obtener el vector de pesos. Cuantas menos características necesitemos para discernir la clase a la que pertenece una instancia de los datos, más simple será clasificar dicha instancia. Se expresa en porcentaje indicando 0 como ninguna simplicidad y 100 como la máxima simplicidad.

	De esta forma combinando ambas tasas obtenemos la tasa agregada que nos hace la media entre ambas tasas, de forma que le asignamos la misma importancia a acertar en la clasificación de las instancias y a la simplicidad en la solución. Cabe destacar que es imposible obtener una tasa de un 100\% a no ser que los datos se compongan únicamente de un punto ya que ello implicaría que la simplicidad ha de ser un 100\% (todos las posiciones del vector menores que 0.2) y por tanto la distancia sería 0 en todos los casos. De esta forma aspiraremos a una calificación lo mas alta posible pero teniendo en cuenta las restricciones de la función objetivo construida.

	Las funciones y operadores de uso común los he agrupado en un fichero llamado auxiliar.py. Este fichero contiene las funciones de lectura de datos, distancias, una función que devuelve el elemento más común de una lista, la norma euclídea, una función para dividir los datos en el número de particiones que queramos manteniendo el porcentaje de elementos de cada clase que había en el conjunto de datos original y el operador de mutación.

	\subsection{Generación de soluciones aleatorias}

	En los algoritmos genéticos y meméticos partimos de una población de soluciones aleatorias que generamos con una distribución uniforme, de forma que partimos en un inicio con una población de 30 individuos con valores en los vectores de pesos entre 0 y 1 generados de forma aleatoria.

	Nótese que en nuestro caso TAM\_POBLACION=30.

	\begin{algorithm}
		\caption{generaPoblacionInicial(longitud)}
		\begin{algorithmic}
			\STATE poblacion $\leftarrow$ [ ]
			\FOR{i=0 , ... , TAM\_POBLACION-1}
				\STATE cromosoma $\leftarrow$ [ ]
				\FOR{j=0 , ... , longitud-1}
					\STATE cromosoma $\leftarrow$ [cromosoma,uniforme(0,1)]
				\ENDFOR
				\STATE poblacion $\leftarrow$ [poblacion,cromosoma]
			\ENDFOR
			\RETURN poblacion
		\end{algorithmic}
	\end{algorithm}

	\subsection{Operador de cruce BLX-$\alpha$}

	Este operador de cruce se usa tanto en los algoritmos genéticos como meméticos.

	Se toman dos padres, de los que hallamos el elemento más grande de su vector de pesos y el más pequeño para poder obtener el máximo y mínimo de los dos. Esto nos va a dar un intervalo de valores para nuestro hijo.

	El hijo se va a generar tomando valores aleatorios con una distribución uniforme que estén en el intervalo $[min\_padres - \delta , max\_padres + \delta]$, donde $\delta = max\_padres - min\_padres$. De esta forma podemos obtener el número que deseemos de hijos tan solo con dos padres, ya que los valores son aleatorios y por tanto los hijos obtenidos serán distintos.

	Nótese que en nuestro caso $\alpha=0.3$

	\begin{algorithm}
		\caption{cruceBLX(cromosoma1, cromosoma2)}
		\begin{algorithmic}
			\STATE hijo $\leftarrow$ [ ]
			\STATE max\_c1 $\leftarrow$ máximo(cromosoma1)
			\STATE max\_c2 $\leftarrow$ máximo(cromosoma2)
			\STATE min\_c1 $\leftarrow$ mínimo(cromosoma1)
			\STATE min\_c2 $\leftarrow$ mínimo(cromosoma2)
			\STATE max\_intervalo $\leftarrow$ máximo(max\_c1,max\_c2)
			\STATE min\_intervalo $\leftarrow$ mínimo(min\_c1,min\_c2)
			\STATE delta $\leftarrow$ $(max\_intervalo-min\_intervalo)\cdot \alpha$
			\FOR{i=0 , ... , longitud(cromosoma1)}
				\STATE hijo $\leftarrow$ $[hijo,uniforme(min\_intervalo - \delta, max\_intervalo + \delta)]$
			\ENDFOR
			\STATE Si hay alguna posición negativa en el hijo se trunca a 0.
			\STATE Si hay alguna posición mayor a 1 en el hijo se trunca a 1.
			\RETURN hijo
		\end{algorithmic}
	\end{algorithm}

	Nótese que hemos tenido que truncar las soluciones, ya que el valor $\delta$ utilizado en el algoritmo puede provocar que el hijo que obtengamos tenga valores fuera del intervalo [0,1], cosa que no tendría sentido para nuestro problema.

	\subsection{Operador de cruce Aritmético}

	El operador de cruce aritmético toma, igual que en el caso anterior, dos padres y devuelve un hijo. En este caso el hijo que obtenemos es único, ya que lo vamos a calcular haciendo la media posición a posición respecto a los dos padres. Esto nos va a garantizar que los hijos estén en el intervalo de definición, no como en el BLX.

	Un inconveniente que puede presentar este algoritmo es que vamos a tener mucha menos posibilidad de obtener valores muy cercanos a 0 o a 1, ya que al realizar la media siempre vamos a ir alejándonos de estos valores.

	\begin{algorithm}
		\caption{cruceAritmetico(cromosoma1,cromosoma2)}
		\begin{algorithmic}
			\STATE hijo $\leftarrow$ [ ]
			\FOR{i=0 , ... , longitud(cromosoma1)}
				\STATE hijo $\leftarrow$ [hijo,$\frac{cromosoma1[i]+cromosoma2[i]}{2}$]
			\ENDFOR
			\RETURN hijo
		\end{algorithmic}
	\end{algorithm}

	\subsection{Función de mutación}

	Esta función recibe como entrada un vector de pesos y una posición que es la que se desea mutar, devolviendo como resultado el vector de pesos ya mutado y la posición aumentada en una unidad (se usa para el algoritmo de búsqueda local aunque puede ignorarse).

	\begin{algorithm}[!h]
		\caption{mutacion(w,pos)}
		\begin{algorithmic}
			\STATE incremento = gauss(mu=0,sigma=0.3)
			\STATE posicion\_nueva = pos+1
			\STATE w[pos]+=incremento
			\STATE Truncar el vector w (0 si es negativo y 1 si es mayor que 1).
			\RETURN w,pos\_nueva
		\end{algorithmic}
	\end{algorithm}

	Esta función es usada en búsqueda local y en todos los genéticos y meméticos a la hora de realizar la mutación de los cromosomas.

	\subsection{Torneo Binario}

	Para la selección de los dos padres utilizamos el torneo binario. Para ello cogemos dos individuos de la población y los comparamos entre sí cogiendo al mejor de los dos. Al repetir esta operación dos veces obtenemos los dos padres que necesitamos.

	\begin{algorithm}
		\caption{torneoBinario(data,poblacion,k,etiquetas,valoraciones)}
		\begin{algorithmic}
			\STATE individuos $\leftarrow$ 2 números aleatorios entre 0 y TAM\_POBLACION-1
			\STATE valoracion\_ind1 $\leftarrow$ valoraciones[individuos[0]]
			\STATE valoracion\_ind2 $\leftarrow$ valoraciones[individuos[1]]
			\IF{valoracion\_ind1$>$valoracion\_ind2}
				\RETURN individuos[0]
			\ELSE
				\RETURN individuos[1]
			\ENDIF
		\end{algorithmic}
	\end{algorithm}

	\newpage

	\section{Genético Estacionario}
	\label{sec:GE}

	El algoritmo genético estacionario se basa en la dinámica de poblaciones como todos los algoritmos genéticos, con la salvedad de que sólo evolucionamos y cruzamos una única pareja de padres para obtener sólo dos hijos en el caso de BLX y para el aritmético haremos lo mismo con cuatro padres para obtener dos hijos de igual forma.

	Partimos de una población inicial de 30 individuos generados de forma aleatoria tal y como se ha explicado en la parte común a todos los algoritmos.

	Tras la obtención de los dos hijos hacemos una mutación con probabilidad de 0.001 en cada gen (posición del vector de pesos).

	Estos dos hijos generados se sumarán a la población existente. Haremos una valoración de la población viendo cuáles son los 30 individuos con mejor puntuación y nos quedaremos con ellos. Esto puede implicar que si los dos hijos generados son peores que el resto de la población desecharemos a los 2 hijos generados y nos volveremos a quedar con la población que teníamos antes de realizar el cruce.

	Haciendo esto vamos a ir obteniendo a cada iteración dos individuos nuevos que se introducirán en la población mejorándola de forma gradual.

	Al final del algoritmo comprobamos cuál de los elementos de la población tiene mejor valoración para devolver al mejor individuo de nuestra población.

	Nótese que la constante TAM\_POBLACION es 30 en nuestro caso y MAX\_EVALUACIONES es 15000

	\begin{algorithm}
		\caption{GeneticoEstacionario(data,k,operador\_cruce)}
		\begin{algorithmic}
			\STATE num\_padres $\leftarrow$ 0
			\IF{operador\_cruce == cruceAritmetico}
				\STATE num\_padres $\leftarrow$ 4
			\ELSIF{operador\_cruce == cruceBLX}
				\STATE num\_padres $\leftarrow$ 2
			\ELSE
				\STATE Error en el operador de cruce.
			\ENDIF
			\STATE
			\STATE poblacion $\leftarrow$ generaPoblacionInicial(numero\_caracteristicas)
			\STATE valoraciones $\leftarrow$ tasa\_agregada + tasa\_reduccion de cada individuo de la poblacion
			\STATE evaluaciones $\leftarrow$ TAM\_POBLACION
			\WHILE{evaluaciones $<$ MAX\_EVALUACIONES}
				\STATE padres $\leftarrow$ Padres escogidos por torneo binario según num\_padres
				\STATE hijos $\leftarrow$ Obtenemos los hijos según operador\_cruce con los padres calculados.
				\STATE
				\STATE Muta cada gen de los hijos si uniforme(0,1) es menor que 0.001.
				\STATE poblacion $\leftarrow$ [poblacion,hijos]
				\STATE valoraciones $\leftarrow$ [valoraciones,valoraciones de los hijos]
				\STATE Obtener los índices que los 30 mejores individuos de la población y quedarse con ellos.
				\STATE Actualizar poblacion y valoraciones según los índices obtenidos.
				\STATE evaluaciones $\leftarrow$ evaluaciones+2
			\ENDWHILE
			\RETURN Devolver al individuo con mayor valoración de la población.
		\end{algorithmic}
	\end{algorithm}

	Donde el parámetro data y k se emplean en la llamada a KNN para obtener una calificación de cada individuo de la población para poder compararlos.

	\newpage

	\section{Genético Generacional}
	\label{sec:GG}

	El algoritmo genético generacional se basa en la dinámica de poblaciones al igual que el estacionario. Este algoritmo, al contrario que el anterior, intenta reemplazar toda o gran parte de la población a cada iteración del mismo de forma que a cada paso mejore una parte sustancial de la misma tras los cruces.

	En nuestro caso el porcentaje escogido es de un 70\% por lo que a cada iteración se generarán $0.7\cdot 30 = 21$ hijos que se introducirán en la población reemplazando a los padres.

	Así mismo vamos a ir guardando a cada paso el mejor individuo de cada generación con la intención de que si el peor de la población generada en esta iteración es peor que el mejor de la anterior lo reemplacemos.

	Esto también nos va a proveer de una forma sencilla de reconocer al mejor individuo una vez acabemos el algoritmo.

	También debemos de tener en cuenta que al igual que en el anterior algoritmo genético vamos a mutar la nueva población generada con una probabilidad de 0.001. En este caso al ser un número mayor de genes vamos a ahorrarnos la generación de números aleatorios mutando siempre un número fijo de los mismos que será $21\cdot num\_caracteristicas\cdot 0.001$.

	\begin{algorithm}
		\caption{GeneticoGeneracional(data,k,operador\_cruce)}
		\begin{algorithmic}
			\STATE poblacion $\leftarrow$ generaPoblacionInicial(num\_caracteristicas)
			\STATE mutaciones $\leftarrow$ PROB\_MUTACION*TAM\_POBLACION*num\_caracteristicas
			\STATE num\_parejas $\leftarrow$ TAM\_POBLACION*PROB\_CRUCE
			\STATE valoraciones $\leftarrow$ valoraciones de la población
			\STATE mejor\_solucion $\leftarrow$ Mejor solución de la población.
			\WHILE{evaluaciones $<$ MAX\_EVALUACIONES}
				\STATE hijos $\leftarrow$ [ ]
				\FOR{i=0 , ... , num\_parejas-1}
					\IF{operador\_cruce==cruceAritmetico}
						\STATE padres $\leftarrow$ genera 4 padres con torneoBinario
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[0],padres[1])]
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[2],padres[3])]
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[0],padres[2])]
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[1],padres[2])]
					\ELSE
						\STATE padres $\leftarrow$ genera 2 padres con torneoBinario
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[0],padres[1])]
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[0],padres[1])]
					\ENDIF
				\ENDFOR
				\STATE Muta la nueva población de hijos con probabilidad 0.001 con una distribución $gauss(\mu=0,\sigma=0.3)$
				\STATE Rellena la población de hijos con padres haciendo torneos binarios.
				\STATE poblacion $\leftarrow$ hijos
				\STATE Actualiza las valoraciones de los individuos.
				\STATE Si el peor de la nueva población es peor que el mejor de la anterior lo sustituimos.
				\STATE Actualiza el mejor de la población.
			\ENDWHILE
			\RETURN Mejor de la población.
		\end{algorithmic}
	\end{algorithm}

	\newpage

	\section{Meméticos}
	\label{sec:memeticos}

	El algoritmo memético toma la misma estructura que el algoritmo genético generacional en cuanto a esquema de evolución, cruce y mutaciones, con la salvedad de que introducimos una fase de explotación en el mismo.

	La variante implementada toma el mismo algoritmo genético generacional y aplica al 10\% de los 30 individuos una búsqueda local para maximizar su valoración. De esta forma vamos a tener un tercio de la población con una valoración mejor que el resto. Esto lo que va a intentar hacer es maximizar y hacer la convergencia mucho más rápida que en los algoritmos genéticos.

	Así mismo este algoritmo está implementado con los dos operadores de cruce con la intención de comprobar cuál es el que nos da mejores resultados con respecto al otro.

	\begin{algorithm}
		\caption{Memetico(data,k,operador\_cruce,nGeneraciones,prob\_bl,mejores=False)}
		\begin{algorithmic}
			\STATE poblacion $\leftarrow$ generaPoblacionInicial(num\_caracteristicas)
			\STATE mutaciones $\leftarrow$ PROB\_MUTACION*TAM\_POBLACION*num\_caracteristicas
			\STATE num\_parejas $\leftarrow$ TAM\_POBLACION*PROB\_CRUCE
			\STATE valoraciones $\leftarrow$ valoraciones de la población
			\STATE mejor\_solucion $\leftarrow$ Mejor solución de la población.
			\STATE contador\_generaciones $\leftarrow$ 1
			\WHILE{evaluaciones $<$ MAX\_EVALUACIONES}
				\IF{contador\_generaciones\%nGeneraciones==0}
					\STATE n\_elem\_bl $\leftarrow$ prob\_bl*TAM\_POBLACION
					\STATE individuos $\leftarrow$ [ ]
					\IF{not mejores}
						\STATE individuos $\leftarrow$ Tomar n\_elem\_bl de forma aleatoria desde 0,...,TAM\_POBLACION-1
					\ELSE
						\STATE individuos $\leftarrow$ Toma los 0.1*TAM\_POBLACION mejores de la poblacion
					\ENDIF
					\FOR{ind en individuos}
						\STATE Aplica la búsqueda local a poblacion[ind]
						\STATE Actualiza el número de evaluaciones.
					\ENDFOR
					\STATE Actualiza las valoraciones
					\STATE Actualiza las evaluaciones.
				\ENDIF
				\STATE
				\STATE hijos $\leftarrow$ [ ]
				\FOR{i=0 , ... , num\_parejas-1}
					\IF{operador\_cruce==cruceAritmetico}
						\STATE padres $\leftarrow$ genera 4 padres con torneoBinario
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[0],padres[1])]
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[2],padres[3])]
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[0],padres[2])]
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[1],padres[2])]
					\ELSE
						\STATE padres $\leftarrow$ genera 2 padres con torneoBinario
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[0],padres[1])]
						\STATE hijos $\leftarrow$ [hijos,operador\_cruce(padres[0],padres[1])]
					\ENDIF
				\ENDFOR
				\STATE Muta la nueva población de hijos con probabilidad 0.001 con una distribución $gauss(\mu=0,\sigma=0.3)$
				\STATE Rellena la población de hijos con padres haciendo torneos binarios.
				\STATE poblacion $\leftarrow$ hijos
				\STATE Actualiza las valoraciones de los individuos.
				\STATE Si el peor de la nueva población es peor que el mejor de la anterior lo sustituimos.
				\STATE Actualiza el mejor de la población.
				\STATE contador\_generaciones $\leftarrow$ contador\_generaciones + 1
			\ENDWHILE
			\RETURN Mejor de la población.
		\end{algorithmic}
	\end{algorithm}

	Donde prob\_bl es el porcentaje de la población al que queremos aplicar la búsqueda local.

	\newpage

	\section{Pseudocódigo KNN}
	\label{sec:knn}

	\begin{algorithm}
		\caption{KNN(w,datos\_test,datos\_entrenamiento, etiquetas\_entrenamiento, etiquetas\_test, k, mismos\_conjuntos)}
		\begin{algorithmic}
			\STATE tam\_datos\_entrenamiento $\leftarrow$ longitud(datos\_entrenamiento)
			\STATE clases $\leftarrow$ []
			\FOR{i=0,...,longitud(datos\_test)}
			\STATE p $\leftarrow$ datos\_test[i]
			\STATE w\_m $\leftarrow$ Repetir el vector w tantas veces como datos haya en datos\_entrenamiento.
			\STATE p\_m $\leftarrow$ Repetir el vector p tantas veces como datos haya en datos\_entrenamiento.
			\STATE dist $\leftarrow$ $w\_m \cdot (p\_m - datos\_entrenamiento)^2$
			\IF{mismos\_conjuntos}
			\STATE dist[i] $\leftarrow$ $\infty$
			\ENDIF
			\STATE mins $\leftarrow$ Los k índices correspondientes a las distancias más pequeñas.
			\STATE clases $\leftarrow$ [clases, masComun(etiquetas\_entrenamiento[mins])]
			\ENDFOR
			\RETURN $\frac{Numero \ de \ elementos \ de \ clases \ que \ han \ acertado \ con \ respecto \ a \ etiquetas\_test}{longitud(etiquetas\_test)}$
		\end{algorithmic}
	\end{algorithm}

	Cabe notar que el número que devolvemos está entre 0 y 1, por lo que en los algoritmos de valoración debemos tener esto en cuenta para multiplicarlo por 100 y convertirlo en un porcentaje.

	\newpage

	\section{Pseudocódigo Relief}
	\label{sec:relief}

	\begin{algorithm}
		\caption{elementoMinimaDistancia(e,lista)}
		\begin{algorithmic}
			\STATE distancias $\leftarrow$ [ ]
			\FOR{l en lista}
			\IF{l!=e}
			\STATE distancias $\leftarrow$ [distancias, distancia(e,l,[1..1])]
			\ELSE
			\STATE distancias $\leftarrow$ [distancias, max(distancias)]
			\ENDIF
			\ENDFOR
			\STATE indice\_menor\_distancia $\leftarrow$ índice del elemento de menor valor del vector distancias.
			\RETURN lista[indice\_menor\_distancia]
		\end{algorithmic}
	\end{algorithm}

	\begin{algorithm}
		\caption{Relief(data)}
		\begin{algorithmic}
			\STATE w $\leftarrow$ vector de pesos a 0
			\FOR{elemento en data}
			\STATE clase $\leftarrow$ clase de elemento
			\STATE amigos $\leftarrow$ [ ]
			\STATE enemigos $\leftarrow$ [ ]
			\FOR{e en data}
			\IF{e!=elemento AND e[longitud(e)-1]==clase}
			\STATE amigos $\leftarrow$ [amigos, e]
			\ELSE
			\STATE enemigos $\leftarrow$ [enemigos, e]
			\ENDIF
			\ENDFOR
			\STATE amigo\_cercano $\leftarrow$ elementoMinimaDistancia(elemento, amigos)
			\STATE enemigo\_cercano $\leftarrow$ elementoMinimaDistancia(elemento, enemigos)
			\STATE resta\_enemigo $\leftarrow$ element-enemigo\_cercano
			\STATE resta\_amigo $\leftarrow$ element-amigo\_cercano
			\STATE w $\leftarrow$ w + resta\_enemigo - resta\_amigo
			\STATE $w_{max}$ $\leftarrow$ máximo de w
			\ENDFOR
			\FOR{i en [0..longitud(w)-1]}
			\IF{w[i]$<$0}
			\STATE w[i] $\leftarrow$ 0
			\ELSE
			\STATE w[i] $\leftarrow$ $\frac{w[i]}{w_{max}}$
			\ENDIF
			\ENDFOR
			\RETURN w
		\end{algorithmic}
	\end{algorithm}

	\newpage

	\section{Pseudocódigo Búsqueda Local}
	\label{sec:bl}

	\begin{algorithm}
		\caption{primerVector(n)}
		\begin{algorithmic}
			\STATE w $\leftarrow$ [ ]
			\FOR{i en [0..n-1]}
			\STATE w $\leftarrow$ [w, random.uniforme(0,1)]
			\ENDFOR
			\RETURN w
		\end{algorithmic}
	\end{algorithm}

	\begin{algorithm}
		\caption{busquedaLocal(data,k)}
		\begin{algorithmic}
			\STATE MAX\_EVALUACIONES $\leftarrow$ 15000
			\STATE MAX\_VECINOS $\leftarrow$ $20\cdot longitud(data[0])$
			\STATE vecinos $\leftarrow$ 0
			\STATE evaluaciones $\leftarrow$ 0
			\STATE posicion\_mutacion $\leftarrow$ 0
			\STATE w $\leftarrow$ primerVector(longitud(data[0]))
			\STATE valoracion\_actual $\leftarrow$ Valoracion(data,data,k,w)
			\WHILE{evaluaciones$<$MAX\_EVALUACIONES AND vecinos$<$MAX\_VECINOS}
				\STATE evaluaciones $\leftarrow$ evaluaciones+1
				\STATE vecinos $\leftarrow$ vecinos+1
				\STATE vecino, posicion\_mutacion $\leftarrow$ mutacion(w,posicion\_mutacion)
				\STATE valoracion\_vecino $\leftarrow$ Valoracion(data,data,k,vecino)
				\IF{valoracion\_vecino$>$valoracion\_actual}
					\STATE vecinos $\leftarrow$ 0
					\STATE w $\leftarrow$ vecino
					\STATE valoracion\_actual $\leftarrow$ valoracion\_vecino
					\STATE posicion\_mutacion $\leftarrow$ 0
				\ELSIF{posicion\_mutacion==longitud(w)}
					\STATE posicion\_mutacion $\leftarrow$ 0
				\ENDIF
			\ENDWHILE
			\RETURN w
		\end{algorithmic}
	\end{algorithm}

	\newpage

	\section{Procedimiento de desarrollo de la práctica}
	\label{sec:procedimiento}

	Las prácticas las he implementado usando python3.5. Los archivos utilizados tienen cada uno el nombre de la temática que tratan, teniendo por ejemplo geneticos.py como el fichero que contiene la implementación de los genéticos o por ejemplo auxiliar.py que es el fichero que contiene funciones que se usan de forma regular por todos los algoritmos o por varios de ellos.

	Para la implementación no he usado ningún framework, aunque he probado a emplear Sklearn para la implementación del algoritmo KNN. Este algoritmo resultó ser más lento que mi versión implementada con la librería numpy por lo que no lo he utilizado al final.

	La ejecución de las prácticas se puede hacer mediante dos programas: resultados.py o main.py.

	En el caso de resultados.py se ejecutan todos los algoritmos sobre todos los conjuntos de datos de forma que obtenemos todo lo necesario para compararlos entre sí. Este fichero se puede ejecutar como 'python3.5 resultados.py'.

	El fichero main.py permite la ejecución de un algoritmo concreto sobre un fichero de datos concreto obteniendo los resultados asociados a dicho fichero y algoritmo. Para ello se nos pide por la ruta del fichero de datos, el valor de la constante k para el KNN, el algoritmo que queremos evaluar y el número de particiones que vamos a hacer del conjunto de datos.

	De igual modo si queremos cambiar la semilla usada en la generación de números aleatorios se puede encontrar al inicio de todos los ficheros de código para cambiarla.

	\section{Resultados}
	\label{sec:resultados}

	\begin{table}[ht]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tabla1NN}
		\caption{Resultados 1NN}
	\end{table}



	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaReliefK1}
		\caption{Resultados Relief con K=1}
	\end{table}



	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaBLK1}
		\caption{Resultados Búsqueda Local con K=1}
	\end{table}


	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaAGGBLXK1}
		\caption{Resultados AGG-BLX con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaAGGCAK1}
		\caption{Resultados AGG-CA con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaAGEBLXK1}
		\caption{Resultados AGE-BLX con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaAGECAK1}
		\caption{Resultados AGE-CA con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaMemetico10-1-BLXK1}
		\caption{Resultados AM(10,1.0) BLX con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaMemetico10-01-BLXK1}
		\caption{Resultados AM(10,0.1) BLX con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaMemetico10-01-mejores-BLXK1}
		\caption{Resultados AM(10,0.1,mejores) BLX con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaMemetico10-1-CAK1}
		\caption{Resultados AM(10,1.0) CA con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaMemetico10-01-CAK1}
		\caption{Resultados AM(10,0.1) CA con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				Partición 1 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 2 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 3 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 4 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Partición 5 &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Media &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaMemetico10-01-mejores-CAK1}
		\caption{Resultados AM(10,0.1,mejores) CA con K=1}
	\end{table}

	\begin{table}[h!]
		\centering
		\resizebox{\textwidth}{!}{
			\begin{tabular}{| c | c | c | c | c | c | c | c | c | c | c | c | c |}
				\cline{2-13}
				\multicolumn{1}{c|}{} & \multicolumn{4}{|c|}{Ozone} & \multicolumn{4}{| c|}{Parkinsons} & \multicolumn{4}{|c|}{Spectf-Heart} \\ [0.5ex]
				\cline{2-13}
				\multicolumn{1}{c|}{} & \%\_clas & \%\_red & Agr. & T (seg) & \%\_clas & \%\_red & Agr. & T  (seg) & \%\_clas & \%\_red & Agr. & T  (seg) \\ [0.5ex] \hline
				1-NN &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				Relief &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				BL &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AGG-BLX &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AGG-CA &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AGE-BLX &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AGE-CA &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AM(10,1) BLX &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AM(10,0.1) BLX &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AM(10,0.1,mejores) BLX &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AM(10,1) CA &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AM(10,0.1) CA &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
				AM(10,0.1,mejores) CA &  &  &  &  &  &  &  &  &  &  &  &  \\ [0.5ex] \hline
			\end{tabular}
		}
		\label{tablaGlobalK1}
		\caption{Resultados globales con K=1}
	\end{table}

\end{document}
